{"doc_id": "673fbc5d", "doc_name": "use-functional-api", "summary": "Introduces LangGraph's Functional API for adding persistence, memory, human-in-the-loop, and streaming to applications with minimal code changes.", "keywords": ["Functional API", "persistence", "memory", "human-in-the-loop", "streaming", "entrypoint", "task", "checkpointer", "InMemorySaver", "workflow"], "structure": [{"node_id": "1f650347", "path": "use-functional-api > Use the functional API", "title": "Use the functional API", "keywords": ["Functional API", "persistence", "memory", "human-in-the-loop", "streaming", "entrypoint", "task", "checkpointer", "InMemorySaver", "workflow"], "summary": "Introduces LangGraph's Functional API for adding persistence, memory, human-in-the-loop, and streaming to applications with minimal code changes.", "nodes": [{"node_id": "19c9e0de", "path": "use-functional-api > Use the functional API > Creating a simple workflow", "title": "Creating a simple workflow", "keywords": ["entrypoint", "task", "checkpointer", "InMemorySaver", "workflow", "invoke", "thread_id", "decorator", "persistence", "functional API"], "summary": "Explains how to create a simple workflow using LangGraph's functional API, including passing multiple inputs via a dictionary and using checkpoints for persistence.", "nodes": []}, {"node_id": "0085ff00", "path": "use-functional-api > Use the functional API > Parallel execution", "title": "Parallel execution", "keywords": ["@task", "@entrypoint", "parallel execution", "futures", "concurrency", "IO bound tasks", "LLM calls", "InMemorySaver", "checkpointer", "workflow"], "summary": "Explains how to execute tasks concurrently in LangGraph using the functional API, with examples for parallel LLM calls to improve performance in IO-bound operations.", "nodes": []}, {"node_id": "c1e9a2b0", "path": "use-functional-api > Use the functional API > Calling graphs", "title": "Calling graphs", "keywords": ["Functional API", "Graph API", "StateGraph", "entrypoint", "invoke", "InMemorySaver", "TypedDict", "checkpointer", "workflow", "compile"], "summary": "Explains how to combine the Functional API and Graph API in LangGraph, allowing graphs to be invoked within functional workflows.", "nodes": []}, {"node_id": "69b4fe5e", "path": "use-functional-api > Use the functional API > Call other entrypoints", "title": "Call other entrypoints", "keywords": ["entrypoint", "task", "invoke", "checkpointer", "InMemorySaver", "sub-workflow", "LangGraph", "thread_id", "configurable", "workflow"], "summary": "Explains how to call other entrypoints from within an entrypoint or task in LangGraph, including automatic checkpointer inheritance and invocation examples.", "nodes": []}, {"node_id": "ffb043fc", "path": "use-functional-api > Use the functional API > Streaming", "title": "Streaming", "keywords": ["Functional API", "streaming", "get_stream_writer", "stream_mode", "StreamWriter", "entrypoint", "InMemorySaver", "updates", "custom data", "async"], "summary": "Explains how to use the streaming API in LangGraph's Functional API to emit custom messages and updates during graph execution, including code examples and async considerations.", "nodes": []}, {"node_id": "420a0bd1", "path": "use-functional-api > Use the functional API > Retry policy", "title": "Retry policy", "keywords": ["RetryPolicy", "InMemorySaver", "entrypoint", "task", "ValueError", "retry_on", "checkpointer", "invoke", "langgraph", "functional API"], "summary": "Demonstrates how to implement a retry policy in LangGraph using the functional API, including configuring a RetryPolicy for specific errors and using a task decorator with retry logic.", "nodes": []}, {"node_id": "297dcb79", "path": "use-functional-api > Use the functional API > Caching Tasks", "title": "Caching Tasks", "keywords": ["CachePolicy", "ttl", "InMemoryCache", "task", "entrypoint", "caching", "slow_add", "stream", "updates", "cached"], "summary": "Demonstrates caching tasks in LangGraph using TTL and InMemoryCache to avoid redundant computations.", "nodes": []}, {"node_id": "eaeb0d42", "path": "use-functional-api > Use the functional API > Resuming after an error", "title": "Resuming after an error", "keywords": ["InMemorySaver", "checkpointer", "entrypoint", "task", "StreamWriter", "thread_id", "resume", "workflow", "checkpoint"], "summary": "Demonstrates how to resume a workflow after an error using checkpoints, preventing re-execution of completed tasks.", "nodes": []}, {"node_id": "f504e207", "path": "use-functional-api > Use the functional API > Human-in-the-loop", "title": "Human-in-the-loop", "keywords": ["interrupt", "Command", "functional API", "human-in-the-loop", "ToolCall", "ToolMessage", "entrypoint", "InMemorySaver", "checkpointer", "call_model"], "summary": "Demonstrates human-in-the-loop workflows in LangGraph's functional API using interrupt and Command for pausing tasks and reviewing tool calls.", "nodes": [{"node_id": "aca70709", "path": "use-functional-api > Use the functional API > Human-in-the-loop > Basic human-in-the-loop workflow", "title": "Basic human-in-the-loop workflow", "keywords": ["LangGraph", "functional API", "human-in-the-loop", "interrupt", "task", "entrypoint", "checkpointer", "Command", "InMemorySaver", "stream"], "summary": "Demonstrates a basic human-in-the-loop workflow using LangGraph's functional API, where a task pauses for human input before resuming execution.", "nodes": []}, {"node_id": "c350c400", "path": "use-functional-api > Use the functional API > Human-in-the-loop > Review tool calls", "title": "Review tool calls", "keywords": ["interrupt", "ToolCall", "ToolMessage", "review_tool_call", "entrypoint", "human-in-the-loop", "InMemorySaver", "call_model", "call_tool", "add_messages"], "summary": "Describes implementing a human-in-the-loop review for tool calls using the `interrupt` function to pause execution, allowing acceptance, revision, or custom feedback before proceeding.", "nodes": []}]}, {"node_id": "49ca6302", "path": "use-functional-api > Use the functional API > Short-term memory", "title": "Short-term memory", "keywords": ["checkpoint", "entrypoint.final", "InMemorySaver", "thread_id", "StateSnapshot", "get_state_history", "PregelTask", "BaseMessage", "ChatAnthropic", "workflow"], "summary": "Explains short-term memory in LangGraph's functional API, covering checkpoint management, decoupling return and saved values, and a chatbot example.", "nodes": [{"node_id": "fff308ff", "path": "use-functional-api > Use the functional API > Short-term memory > Manage checkpoints", "title": "Manage checkpoints", "keywords": ["checkpoint", "get_state", "thread_id", "StateSnapshot", "get_state_history", "messages", "metadata", "HumanMessage", "AIMessage", "PregelTask"], "summary": "Manage checkpoints to view and delete stored thread state and history using the functional API.", "nodes": [{"node_id": "cf90fdb5", "path": "use-functional-api > Use the functional API > Short-term memory > Manage checkpoints > View thread state", "title": "View thread state", "keywords": ["get_state", "thread_id", "checkpoint_id", "StateSnapshot", "messages", "metadata", "configurable", "HumanMessage", "AIMessage", "graph"], "summary": "Retrieve and inspect the state of a specific thread, including messages and metadata, using the functional API's get_state method.", "nodes": []}, {"node_id": "77e1d3eb", "path": "use-functional-api > Use the functional API > Short-term memory > Manage checkpoints > View the history of the thread", "title": "View the history of the thread", "keywords": ["StateSnapshot", "get_state_history", "thread_id", "configurable", "messages", "HumanMessage", "AIMessage", "checkpoint_id", "metadata", "PregelTask"], "summary": "Demonstrates how to retrieve the complete state history of a conversation thread using the functional API, showing a sequence of StateSnapshot objects.", "nodes": []}]}, {"node_id": "cafeff51", "path": "use-functional-api > Use the functional API > Short-term memory > Decouple return value from saved value", "title": "Decouple return value from saved value", "keywords": ["entrypoint.final", "checkpoint", "InMemorySaver", "previous parameter", "state persistence", "return value", "saved value", "accumulate", "invoke", "configurable"], "summary": "Explains how to use `entrypoint.final` to separate the value returned to the caller from the value saved in the checkpoint for state persistence across invocations.", "nodes": []}, {"node_id": "f1f5bc17", "path": "use-functional-api > Use the functional API > Short-term memory > Chatbot example", "title": "Chatbot example", "keywords": ["LangGraph", "functional API", "InMemorySaver", "ChatAnthropic", "checkpointer", "workflow", "entrypoint", "task", "BaseMessage", "add_messages"], "summary": "A simple chatbot example using LangGraph's functional API and InMemorySaver for conversation memory, demonstrating multi-turn dialogue.", "nodes": []}]}, {"node_id": "5f1e897e", "path": "use-functional-api > Use the functional API > Long-term memory", "title": "Long-term memory", "keywords": ["long-term memory", "functional API", "thread ids", "memory", "conversation", "information storage", "user data", "cross-thread"], "summary": "Long-term memory in functional API enables storing information across different thread IDs for reuse in subsequent conversations.", "nodes": []}, {"node_id": "e76c01c1", "path": "use-functional-api > Use the functional API > Workflows", "title": "Workflows", "keywords": ["Functional API", "workflows", "agents", "LangGraph", "build workflows"], "summary": "Guide on building workflows using the Functional API, with examples from workflows and agents.", "nodes": []}, {"node_id": "58597485", "path": "use-functional-api > Use the functional API > Integrate with other libraries", "title": "Integrate with other libraries", "keywords": ["LangGraph", "functional API", "persistence", "memory", "streaming", "agent frameworks", "integration", "deploy-other-frameworks"], "summary": "Explains how to integrate LangGraph's functional API features, such as persistence, memory, and streaming, into other agent frameworks that lack native support.", "nodes": []}]}]}