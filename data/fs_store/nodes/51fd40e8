{"node_id": "51fd40e8", "title": "When to use the Graph API", "path": "choosing-apis > Choosing between Graph and Functional APIs > Detailed comparison > When to use the Graph API", "content": "The [Graph API](/oss/python/langgraph/graph-api) uses a declarative approach where you define nodes, edges, and shared state to create a visual graph structure.\n\n**1. Complex decision trees and branching logic**\n\nWhen your workflow has multiple decision points that depend on various conditions, the Graph API makes these branches explicit and easy to visualize.\n\n```python  theme={null}\n# Graph API: Clear visualization of decision paths\nfrom langgraph.graph import StateGraph\nfrom typing import TypedDict\n\nclass AgentState(TypedDict):\n    messages: list\n    current_tool: str\n    retry_count: int\n\ndef should_continue(state):\n    if state[\"retry_count\"] > 3:\n        return \"end\"\n    elif state[\"current_tool\"] == \"search\":\n        return \"process_search\"\n    else:\n        return \"call_llm\"\n\nworkflow = StateGraph(AgentState)\nworkflow.add_node(\"call_llm\", call_llm_node)\nworkflow.add_node(\"process_search\", search_node)\nworkflow.add_conditional_edges(\"call_llm\", should_continue)\n```\n\n**2. State management across multiple components**\n\nWhen you need to share and coordinate state between different parts of your workflow, the Graph API's explicit state management is beneficial.\n\n```python  theme={null}\n# Multiple nodes can access and modify shared state\nclass WorkflowState(TypedDict):\n    user_input: str\n    search_results: list\n    generated_response: str\n    validation_status: str\n\ndef search_node(state):\n    # Access shared state\n    results = search(state[\"user_input\"])\n    return {\"search_results\": results}\n\ndef validation_node(state):\n    # Access results from previous node\n    is_valid = validate(state[\"generated_response\"])\n    return {\"validation_status\": \"valid\" if is_valid else \"invalid\"}\n```\n\n**3. Parallel processing with synchronization**\n\nWhen you need to run multiple operations in parallel and then combine their results, the Graph API handles this naturally.\n\n```python  theme={null}\n# Parallel processing of multiple data sources\nworkflow.add_node(\"fetch_news\", fetch_news)\nworkflow.add_node(\"fetch_weather\", fetch_weather)\nworkflow.add_node(\"fetch_stocks\", fetch_stocks)\nworkflow.add_node(\"combine_data\", combine_all_data)\n\n# All fetch operations run in parallel\nworkflow.add_edge(START, \"fetch_news\")\nworkflow.add_edge(START, \"fetch_weather\")\nworkflow.add_edge(START, \"fetch_stocks\")\n\n# Combine waits for all parallel operations to complete\nworkflow.add_edge(\"fetch_news\", \"combine_data\")\nworkflow.add_edge(\"fetch_weather\", \"combine_data\")\nworkflow.add_edge(\"fetch_stocks\", \"combine_data\")\n```\n\n**4. Team development and documentation**\n\nThe visual nature of the Graph API makes it easier for teams to understand, document, and maintain complex workflows.\n\n```python  theme={null}\n# Clear separation of concerns - each team member can work on different nodes\nworkflow.add_node(\"data_ingestion\", data_team_function)\nworkflow.add_node(\"ml_processing\", ml_team_function)\nworkflow.add_node(\"business_logic\", product_team_function)\nworkflow.add_node(\"output_formatting\", frontend_team_function)\n```", "summary": "Describes scenarios where the Graph API is advantageous: complex decision trees, state management, parallel processing, and team collaboration.", "keywords": ["Graph API", "StateGraph", "conditional edges", "parallel processing", "state management", "nodes", "edges", "declarative approach", "workflow", "visual graph"]}