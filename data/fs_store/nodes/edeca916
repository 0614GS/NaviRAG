{"node_id": "edeca916", "title": "Use in subgraphs", "path": "add-memory > Memory > Add short-term memory > Use in subgraphs", "content": "If your graph contains [subgraphs](/oss/python/langgraph/use-subgraphs), you only need to provide the checkpointer when compiling the parent graph. LangGraph will automatically propagate the checkpointer to the child subgraphs.\n\n```python  theme={null}\nfrom langgraph.graph import START, StateGraph\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import TypedDict\n\nclass State(TypedDict):\n    foo: str\n\n# Subgraph\n\ndef subgraph_node_1(state: State):\n    return {\"foo\": state[\"foo\"] + \"bar\"}\n\nsubgraph_builder = StateGraph(State)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()  # [!code highlight]\n\n# Parent graph\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", subgraph)  # [!code highlight]\nbuilder.add_edge(START, \"node_1\")\n\ncheckpointer = InMemorySaver()\ngraph = builder.compile(checkpointer=checkpointer)  # [!code highlight]\n```\n\nIf you want the subgraph to have its own memory, you can compile it with the appropriate checkpointer option. This is useful in [multi-agent](/oss/python/langchain/multi-agent) systems, if you want agents to keep track of their internal message histories.\n\n```python  theme={null}\nsubgraph_builder = StateGraph(...)\nsubgraph = subgraph_builder.compile(checkpointer=True)  # [!code highlight]\n```", "summary": "Explains how to propagate checkpoints to subgraphs in LangGraph for memory management, including code examples for shared and separate memory.", "keywords": ["LangGraph", "subgraphs", "checkpointer", "InMemorySaver", "StateGraph", "compile", "memory management", "multi-agent systems"]}