{"node_id": "f834c3d3", "title": "Checkpoints", "path": "persistence > Persistence > Checkpoints", "content": "The state of a thread at a particular point in time is called a checkpoint. Checkpoint is a snapshot of the graph state saved at each super-step and is represented by `StateSnapshot` object with the following key properties:\n\n* `config`: Config associated with this checkpoint.\n* `metadata`: Metadata associated with this checkpoint.\n* `values`: Values of the state channels at this point in time.\n* `next` A tuple of the node names to execute next in the graph.\n* `tasks`: A tuple of `PregelTask` objects that contain information about next tasks to be executed. If the step was previously attempted, it will include error information. If a graph was interrupted [dynamically](/oss/python/langgraph/interrupts#pause-using-interrupt) from within a node, tasks will contain additional data associated with interrupts.\n\nCheckpoints are persisted and can be used to restore the state of a thread at a later time.\n\nLet's see what checkpoints are saved when a simple graph is invoked as follows:\n\n```python  theme={null}\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom langchain_core.runnables import RunnableConfig\nfrom typing import Annotated\nfrom typing_extensions import TypedDict\nfrom operator import add\n\nclass State(TypedDict):\n    foo: str\n    bar: Annotated[list[str], add]\n\ndef node_a(state: State):\n    return {\"foo\": \"a\", \"bar\": [\"a\"]}\n\ndef node_b(state: State):\n    return {\"foo\": \"b\", \"bar\": [\"b\"]}\n\n\nworkflow = StateGraph(State)\nworkflow.add_node(node_a)\nworkflow.add_node(node_b)\nworkflow.add_edge(START, \"node_a\")\nworkflow.add_edge(\"node_a\", \"node_b\")\nworkflow.add_edge(\"node_b\", END)\n\ncheckpointer = InMemorySaver()\ngraph = workflow.compile(checkpointer=checkpointer)\n\nconfig: RunnableConfig = {\"configurable\": {\"thread_id\": \"1\"}}\ngraph.invoke({\"foo\": \"\", \"bar\":[]}, config)\n```\n\nAfter we run the graph, we expect to see exactly 4 checkpoints:\n\n* Empty checkpoint with [`START`](https://reference.langchain.com/python/langgraph/constants/#langgraph.constants.START) as the next node to be executed\n* Checkpoint with the user input `{'foo': '', 'bar': []}` and `node_a` as the next node to be executed\n* Checkpoint with the outputs of `node_a` `{'foo': 'a', 'bar': ['a']}` and `node_b` as the next node to be executed\n* Checkpoint with the outputs of `node_b` `{'foo': 'b', 'bar': ['a', 'b']}` and no next nodes to be executed\n\nNote that we `bar` channel values contain outputs from both nodes as we have a reducer for `bar` channel.", "summary": "Defines checkpoints as thread state snapshots (StateSnapshot) in LangGraph, detailing their properties, persistence, and usage for state restoration and replay.", "keywords": ["StateSnapshot", "checkpoint", "PregelTask", "thread_id", "configurable", "get_state", "get_state_history", "replay", "update_state", "InMemorySaver"]}