{"node_id": "66c996cf", "title": "Handle errors appropriately", "path": "thinking-in-langgraph > Thinking in LangGraph > Step 4: Build your nodes > Handle errors appropriately", "content": "Different errors need different handling strategies:\n\n| Error Type                                                      | Who Fixes It       | Strategy                           | When to Use                                      |\n| --------------------------------------------------------------- | ------------------ | ---------------------------------- | ------------------------------------------------ |\n| Transient errors (network issues, rate limits)                  | System (automatic) | Retry policy                       | Temporary failures that usually resolve on retry |\n| LLM-recoverable errors (tool failures, parsing issues)          | LLM                | Store error in state and loop back | LLM can see the error and adjust its approach    |\n| User-fixable errors (missing information, unclear instructions) | Human              | Pause with `interrupt()`           | Need user input to proceed                       |\n| Unexpected errors                                               | Developer          | Let them bubble up                 | Unknown issues that need debugging               |\n\n<Tabs>\n  <Tab title=\"Transient errors\" icon=\"rotate\">\n    Add a retry policy to automatically retry network issues and rate limits:\n\n    ```python  theme={null}\n    from langgraph.types import RetryPolicy\n\n    workflow.add_node(\n        \"search_documentation\",\n        search_documentation,\n        retry_policy=RetryPolicy(max_attempts=3, initial_interval=1.0)\n    )\n    ```\n  </Tab>\n\n  <Tab title=\"LLM-recoverable\" icon=\"brain\">\n    Store the error in state and loop back so the LLM can see what went wrong and try again:\n\n    ```python  theme={null}\n    from langgraph.types import Command\n\n\n    def execute_tool(state: State) -> Command[Literal[\"agent\", \"execute_tool\"]]:\n        try:\n            result = run_tool(state['tool_call'])\n            return Command(update={\"tool_result\": result}, goto=\"agent\")\n        except ToolError as e:\n            # Let the LLM see what went wrong and try again\n            return Command(\n                update={\"tool_result\": f\"Tool error: {str(e)}\"},\n                goto=\"agent\"\n            )\n    ```\n  </Tab>\n\n  <Tab title=\"User-fixable\" icon=\"user\">\n    Pause and collect information from the user when needed (like account IDs, order numbers, or clarifications):\n\n    ```python  theme={null}\n    from langgraph.types import Command\n\n\n    def lookup_customer_history(state: State) -> Command[Literal[\"draft_response\"]]:\n        if not state.get('customer_id'):\n            user_input = interrupt({\n                \"message\": \"Customer ID needed\",\n                \"request\": \"Please provide the customer's account ID to look up their subscription history\"\n            })\n            return Command(\n                update={\"customer_id\": user_input['customer_id']},\n                goto=\"lookup_customer_history\"\n            )\n        # Now proceed with the lookup\n        customer_data = fetch_customer_history(state['customer_id'])\n        return Command(update={\"customer_history\": customer_data}, goto=\"draft_response\")\n    ```\n  </Tab>\n\n  <Tab title=\"Unexpected\" icon=\"triangle-exclamation\">\n    Let them bubble up for debugging. Don't catch what you can't handle:\n\n    ```python  theme={null}\n    def send_reply(state: EmailAgentState):\n        try:\n            email_service.send(state[\"draft_response\"])\n        except Exception:\n            raise  # Surface unexpected errors\n    ```\n  </Tab>\n</Tabs>", "summary": "A guide to error handling strategies in LangGraph, covering transient, LLM-recoverable, user-fixable, and unexpected errors with corresponding code examples.", "keywords": ["RetryPolicy", "interrupt()", "Command", "ToolError", "transient errors", "LLM-recoverable errors", "user-fixable errors", "unexpected errors", "state", "workflow.add_node"]}