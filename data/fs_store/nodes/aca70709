{"node_id": "aca70709", "title": "Basic human-in-the-loop workflow", "path": "use-functional-api > Use the functional API > Human-in-the-loop > Basic human-in-the-loop workflow", "content": "We will create three [tasks](/oss/python/langgraph/functional-api#task):\n\n1. Append `\"bar\"`.\n2. Pause for human input. When resuming, append human input.\n3. Append `\"qux\"`.\n\n```python  theme={null}\nfrom langgraph.func import entrypoint, task\nfrom langgraph.types import Command, interrupt\n\n\n@task\ndef step_1(input_query):\n    \"\"\"Append bar.\"\"\"\n    return f\"{input_query} bar\"\n\n\n@task\ndef human_feedback(input_query):\n    \"\"\"Append user input.\"\"\"\n    feedback = interrupt(f\"Please provide feedback: {input_query}\")\n    return f\"{input_query} {feedback}\"\n\n\n@task\ndef step_3(input_query):\n    \"\"\"Append qux.\"\"\"\n    return f\"{input_query} qux\"\n```\n\nWe can now compose these tasks in an [entrypoint](/oss/python/langgraph/functional-api#entrypoint):\n\n```python  theme={null}\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\n\n@entrypoint(checkpointer=checkpointer)\ndef graph(input_query):\n    result_1 = step_1(input_query).result()\n    result_2 = human_feedback(result_1).result()\n    result_3 = step_3(result_2).result()\n\n    return result_3\n```\n\n[interrupt()](/oss/python/langgraph/interrupts#pause-using-interrupt) is called inside a task, enabling a human to review and edit the output of the previous task. The results of prior tasks-- in this case `step_1`-- are persisted, so that they are not run again following the [`interrupt`](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt).\n\nLet's send in a query string:\n\n```python  theme={null}\nconfig = {\"configurable\": {\"thread_id\": \"1\"}}\n\nfor event in graph.stream(\"foo\", config):\n    print(event)\n    print(\"\\n\")\n```\n\nNote that we've paused with an [`interrupt`](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt) after `step_1`. The interrupt provides instructions to resume the run. To resume, we issue a [`Command`](/oss/python/langgraph/interrupts#resuming-interrupts) containing the data expected by the `human_feedback` task.\n\n```python  theme={null}\n# Continue execution\nfor event in graph.stream(Command(resume=\"baz\"), config):\n    print(event)\n    print(\"\\n\")\n```\n\nAfter resuming, the run proceeds through the remaining step and terminates as expected.", "summary": "Demonstrates a basic human-in-the-loop workflow using LangGraph's functional API, where a task pauses for human input before resuming execution.", "keywords": ["LangGraph", "functional API", "human-in-the-loop", "interrupt", "task", "entrypoint", "checkpointer", "Command", "InMemorySaver", "stream"]}