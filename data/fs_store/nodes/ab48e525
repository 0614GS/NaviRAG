{"node_id": "ab48e525", "title": "When to use the Functional API", "path": "choosing-apis > Choosing between Graph and Functional APIs > Detailed comparison > When to use the Functional API", "content": "The [Functional API](/oss/python/langgraph/functional-api) uses an imperative approach that integrates LangGraph features into standard procedural code.\n\n**1. Existing procedural code**\n\nWhen you have existing code that uses standard control flow and want to add LangGraph features with minimal refactoring.\n\n```python  theme={null}\n# Functional API: Minimal changes to existing code\nfrom langgraph.func import entrypoint, task\n\n@task\ndef process_user_input(user_input: str) -> dict:\n    # Existing function with minimal changes\n    return {\"processed\": user_input.lower().strip()}\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(user_input: str) -> str:\n    # Standard Python control flow\n    processed = process_user_input(user_input).result()\n\n    if \"urgent\" in processed[\"processed\"]:\n        response = handle_urgent_request(processed).result()\n    else:\n        response = handle_normal_request(processed).result()\n\n    return response\n```\n\n**2. Linear workflows with simple logic**\n\nWhen your workflow is primarily sequential with straightforward conditional logic.\n\n```python  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef essay_workflow(topic: str) -> dict:\n    # Linear flow with simple branching\n    outline = create_outline(topic).result()\n\n    if len(outline[\"points\"]) < 3:\n        outline = expand_outline(outline).result()\n\n    draft = write_draft(outline).result()\n\n    # Human review checkpoint\n    feedback = interrupt({\"draft\": draft, \"action\": \"Please review\"})\n\n    if feedback == \"approve\":\n        final_essay = draft\n    else:\n        final_essay = revise_essay(draft, feedback).result()\n\n    return {\"essay\": final_essay}\n```\n\n**3. Rapid prototyping**\n\nWhen you want to quickly test ideas without the overhead of defining state schemas and graph structures.\n\n```python  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef quick_prototype(data: dict) -> dict:\n    # Fast iteration - no state schema needed\n    step1_result = process_step1(data).result()\n    step2_result = process_step2(step1_result).result()\n\n    return {\"final_result\": step2_result}\n```\n\n**4. Function-scoped state management**\n\nWhen your state is naturally scoped to individual functions and doesn't need to be shared broadly.\n\n```python  theme={null}\n@task\ndef analyze_document(document: str) -> dict:\n    # Local state management within function\n    sections = extract_sections(document)\n    summaries = [summarize(section) for section in sections]\n    key_points = extract_key_points(summaries)\n\n    return {\n        \"sections\": len(sections),\n        \"summaries\": summaries,\n        \"key_points\": key_points\n    }\n\n@entrypoint(checkpointer=checkpointer)\ndef document_processor(document: str) -> dict:\n    analysis = analyze_document(document).result()\n    # State is passed between functions as needed\n    return generate_report(analysis).result()\n```", "summary": "Describes scenarios for using the Functional API in LangGraph, including integrating with existing procedural code, linear workflows, rapid prototyping, and function-scoped state management.", "keywords": ["Functional API", "LangGraph", "entrypoint", "task", "checkpointer", "procedural code", "state management", "rapid prototyping", "linear workflows"]}