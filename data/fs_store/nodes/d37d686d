{"node_id": "d37d686d", "title": "Using tasks in nodes", "path": "durable-execution > Durable execution > Using tasks in nodes", "content": "If a [node](/oss/python/langgraph/graph-api#nodes) contains multiple operations, you may find it easier to convert each operation into a **task** rather than refactor the operations into individual nodes.\n\n<Tabs>\n  <Tab title=\"Original\">\n    ```python  theme={null}\n    from typing import NotRequired\n    from typing_extensions import TypedDict\n    import uuid\n\n    from langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.graph import StateGraph, START, END\n    import requests\n\n    # Define a TypedDict to represent the state\n    class State(TypedDict):\n        url: str\n        result: NotRequired[str]\n\n    def call_api(state: State):\n        \"\"\"Example node that makes an API request.\"\"\"\n        result = requests.get(state['url']).text[:100]  # Side-effect  # [!code highlight]\n        return {\n            \"result\": result\n        }\n\n    # Create a StateGraph builder and add a node for the call_api function\n    builder = StateGraph(State)\n    builder.add_node(\"call_api\", call_api)\n\n    # Connect the start and end nodes to the call_api node\n    builder.add_edge(START, \"call_api\")\n    builder.add_edge(\"call_api\", END)\n\n    # Specify a checkpointer\n    checkpointer = InMemorySaver()\n\n    # Compile the graph with the checkpointer\n    graph = builder.compile(checkpointer=checkpointer)\n\n    # Define a config with a thread ID.\n    thread_id = uuid.uuid4()\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n\n    # Invoke the graph\n    graph.invoke({\"url\": \"https://www.example.com\"}, config)\n    ```\n  </Tab>\n\n  <Tab title=\"With task\">\n    ```python  theme={null}\n    from typing import NotRequired\n    from typing_extensions import TypedDict\n    import uuid\n\n    from langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.func import task\n    from langgraph.graph import StateGraph, START, END\n    import requests\n\n    # Define a TypedDict to represent the state\n    class State(TypedDict):\n        urls: list[str]\n        result: NotRequired[list[str]]\n\n\n    @task\n    def _make_request(url: str):\n        \"\"\"Make a request.\"\"\"\n        return requests.get(url).text[:100]  # [!code highlight]\n\n    def call_api(state: State):\n        \"\"\"Example node that makes an API request.\"\"\"\n        requests = [_make_request(url) for url in state['urls']]  # [!code highlight]\n        results = [request.result() for request in requests]\n        return {\n            \"results\": results\n        }\n\n    # Create a StateGraph builder and add a node for the call_api function\n    builder = StateGraph(State)\n    builder.add_node(\"call_api\", call_api)\n\n    # Connect the start and end nodes to the call_api node\n    builder.add_edge(START, \"call_api\")\n    builder.add_edge(\"call_api\", END)\n\n    # Specify a checkpointer\n    checkpointer = InMemorySaver()\n\n    # Compile the graph with the checkpointer\n    graph = builder.compile(checkpointer=checkpointer)\n\n    # Define a config with a thread ID.\n    thread_id = uuid.uuid4()\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n\n    # Invoke the graph\n    graph.invoke({\"urls\": [\"https://www.example.com\"]}, config)\n    ```\n  </Tab>\n</Tabs>", "summary": "Demonstrates converting multiple operations within a single node into tasks using LangGraph's @task decorator for cleaner code and parallel execution.", "keywords": ["LangGraph", "task", "StateGraph", "node", "checkpointer", "InMemorySaver", "TypedDict", "parallel execution", "API request", "graph compilation"]}