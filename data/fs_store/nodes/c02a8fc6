{"node_id": "c02a8fc6", "title": "Functional API overview", "path": "functional-api > Functional API overview", "content": "The **Functional API** allows you to add LangGraph's key features — [persistence](/oss/python/langgraph/persistence), [memory](/oss/python/langgraph/add-memory), [human-in-the-loop](/oss/python/langgraph/interrupts), and [streaming](/oss/python/langgraph/streaming) — to your applications with minimal changes to your existing code.\n\nIt is designed to integrate these features into existing code that may use standard language primitives for branching and control flow, such as `if` statements, `for` loops, and function calls. Unlike many data orchestration frameworks that require restructuring code into an explicit pipeline or DAG, the Functional API allows you to incorporate these capabilities without enforcing a rigid execution model.\n\nThe Functional API uses two key building blocks:\n\n* **`@entrypoint`** – Marks a function as the starting point of a workflow, encapsulating logic and managing execution flow, including handling long-running tasks and interrupts.\n* **[`@task`](https://reference.langchain.com/python/langgraph/func/#langgraph.func.task)** – Represents a discrete unit of work, such as an API call or data processing step, that can be executed asynchronously within an entrypoint. Tasks return a future-like object that can be awaited or resolved synchronously.\n\nThis provides a minimal abstraction for building workflows with state management and streaming.\n\n<Tip>\n  For information on how to use the functional API, see [Use Functional API](/oss/python/langgraph/use-functional-api).\n</Tip>", "summary": "Introduces LangGraph's Functional API for adding persistence, memory, human-in-the-loop, and streaming to applications with minimal code changes, using @entrypoint and @task decorators.", "keywords": ["Functional API", "@entrypoint", "@task", "LangGraph", "checkpointing", "workflow", "persistence", "human-in-the-loop", "streaming", "determinism"]}