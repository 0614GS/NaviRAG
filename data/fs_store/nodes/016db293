{"node_id": "016db293", "title": "Handling side effects", "path": "functional-api > Functional API overview > Common Pitfalls > Handling side effects", "content": "Encapsulate side effects (e.g., writing to a file, sending an email) in tasks to ensure they are not executed multiple times when resuming a workflow.\n\n<Tabs>\n  <Tab title=\"Incorrect\">\n    In this example, a side effect (writing to a file) is directly included in the workflow, so it will be executed a second time when resuming the workflow.\n\n    ```python  theme={null}\n    @entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        # This code will be executed a second time when resuming the workflow.\n        # Which is likely not what you want.\n        with open(\"output.txt\", \"w\") as f:  # [!code highlight]\n            f.write(\"Side effect executed\")  # [!code highlight]\n        value = interrupt(\"question\")\n        return value\n    ```\n  </Tab>\n\n  <Tab title=\"Correct\">\n    In this example, the side effect is encapsulated in a task, ensuring consistent execution upon resumption.\n\n    ```python  theme={null}\n    from langgraph.func import task\n\n    @task  # [!code highlight]\n    def write_to_file():  # [!code highlight]\n        with open(\"output.txt\", \"w\") as f:\n            f.write(\"Side effect executed\")\n\n    @entrypoint(checkpointer=checkpointer)\n    def my_workflow(inputs: dict) -> int:\n        # The side effect is now encapsulated in a task.\n        write_to_file().result()\n        value = interrupt(\"question\")\n        return value\n    ```\n  </Tab>\n</Tabs>", "summary": "Explains how to encapsulate side effects in tasks to prevent multiple executions when resuming a workflow, with code examples.", "keywords": ["side effects", "tasks", "workflow", "resuming", "encapsulation", "checkpointer", "entrypoint", "interrupt"]}