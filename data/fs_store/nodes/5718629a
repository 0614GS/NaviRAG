{"node_id": "5718629a", "title": "Keep state raw, format prompts on-demand", "path": "thinking-in-langgraph > Thinking in LangGraph > Step 3: Design your state > Keep state raw, format prompts on-demand", "content": "<Tip>\n  A key principle: your state should store raw data, not formatted text. Format prompts inside nodes when you need them.\n</Tip>\n\nThis separation means:\n\n* Different nodes can format the same data differently for their needs\n* You can change prompt templates without modifying your state schema\n* Debugging is clearer – you see exactly what data each node received\n* Your agent can evolve without breaking existing state\n\nLet's define our state:\n\n```python  theme={null}\nfrom typing import TypedDict, Literal\n\n# Define the structure for email classification\nclass EmailClassification(TypedDict):\n    intent: Literal[\"question\", \"bug\", \"billing\", \"feature\", \"complex\"]\n    urgency: Literal[\"low\", \"medium\", \"high\", \"critical\"]\n    topic: str\n    summary: str\n\nclass EmailAgentState(TypedDict):\n    # Raw email data\n    email_content: str\n    sender_email: str\n    email_id: str\n\n    # Classification result\n    classification: EmailClassification | None\n\n    # Raw search/API results\n    search_results: list[str] | None  # List of raw document chunks\n    customer_history: dict | None  # Raw customer data from CRM\n\n    # Generated content\n    draft_response: str | None\n    messages: list[str] | None\n```\n\nNotice that the state contains only raw data – no prompt templates, no formatted strings, no instructions. The classification output is stored as a single dictionary, straight from the LLM.", "summary": "Advocates storing raw data in state and formatting prompts within nodes for flexibility, clarity, and maintainability in agent design.", "keywords": ["state", "raw data", "prompt templates", "nodes", "EmailAgentState", "EmailClassification", "TypedDict", "formatting", "debugging", "agent evolution"]}