{"node_id": "7d3523f5", "title": "Proactive recursion handling", "path": "graph-api > Graph API overview > Runtime context > Accessing and handling the recursion counter > Proactive recursion handling", "content": "LangGraph provides a `RemainingSteps` managed value that tracks how many steps remain before hitting the recursion limit. This allows for graceful degradation within your graph.\n\n```python  theme={null}\nfrom typing import Annotated, Literal\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.managed import RemainingSteps\n\nclass State(TypedDict):\n    messages: Annotated[list, lambda x, y: x + y]\n    remaining_steps: RemainingSteps  # Managed value - tracks steps until limit\n\ndef reasoning_node(state: State) -> dict:\n    # RemainingSteps is automatically populated by LangGraph\n    remaining = state[\"remaining_steps\"]\n\n    # Check if we're running low on steps\n    if remaining <= 2:\n        return {\"messages\": [\"Approaching limit, wrapping up...\"]}\n\n    # Normal processing\n    return {\"messages\": [\"thinking...\"]}\n\ndef route_decision(state: State) -> Literal[\"reasoning_node\", \"fallback_node\"]:\n    \"\"\"Route based on remaining steps\"\"\"\n    if state[\"remaining_steps\"] <= 2:\n        return \"fallback_node\"\n    return \"reasoning_node\"\n\ndef fallback_node(state: State) -> dict:\n    \"\"\"Handle cases where recursion limit is approaching\"\"\"\n    return {\"messages\": [\"Reached complexity limit, providing best effort answer\"]}\n\n# Build graph\nbuilder = StateGraph(State)\nbuilder.add_node(\"reasoning_node\", reasoning_node)\nbuilder.add_node(\"fallback_node\", fallback_node)\nbuilder.add_edge(START, \"reasoning_node\")\nbuilder.add_conditional_edges(\"reasoning_node\", route_decision)\nbuilder.add_edge(\"fallback_node\", END)\n\ngraph = builder.compile()\n\n# RemainingSteps works with any recursion_limit\nresult = graph.invoke({\"messages\": []}, {\"recursion_limit\": 10})\n```", "summary": "LangGraph's RemainingSteps managed value tracks steps before recursion limit, enabling graceful degradation and conditional routing in state graphs.", "keywords": ["RemainingSteps", "LangGraph", "recursion limit", "StateGraph", "managed value", "conditional edges", "graceful degradation", "runtime context"]}