{"node_id": "ba1da9ee", "title": "Proactive vs reactive approaches", "path": "graph-api > Graph API overview > Runtime context > Accessing and handling the recursion counter > Proactive vs reactive approaches", "content": "There are two main approaches to handling recursion limits: proactive (monitoring within the graph) and reactive (catching errors externally).\n\n```python  theme={null}\nfrom typing import Annotated, Literal, TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.managed import RemainingSteps\nfrom langgraph.errors import GraphRecursionError\n\nclass State(TypedDict):\n    messages: Annotated[list, lambda x, y: x + y]\n    remaining_steps: RemainingSteps\n\n# Proactive Approach (recommended) - using RemainingSteps\ndef agent_with_monitoring(state: State) -> dict:\n    \"\"\"Proactively monitor and handle recursion within the graph\"\"\"\n    remaining = state[\"remaining_steps\"]\n\n    # Early detection - route to internal handling\n    if remaining <= 2:\n        return {\n            \"messages\": [\"Approaching limit, returning partial result\"]\n        }\n\n    # Normal processing\n    return {\"messages\": [f\"Processing... ({remaining} steps remaining)\"]}\n\ndef route_decision(state: State) -> Literal[\"agent\", END]:\n    if state[\"remaining_steps\"] <= 2:\n        return END\n    return \"agent\"\n\n# Build graph\nbuilder = StateGraph(State)\nbuilder.add_node(\"agent\", agent_with_monitoring)\nbuilder.add_edge(START, \"agent\")\nbuilder.add_conditional_edges(\"agent\", route_decision)\ngraph = builder.compile()\n\n# Proactive: Graph completes gracefully\nresult = graph.invoke({\"messages\": []}, {\"recursion_limit\": 10})\n\n# Reactive Approach (fallback) - catching error externally\ntry:\n    result = graph.invoke({\"messages\": []}, {\"recursion_limit\": 10})\nexcept GraphRecursionError as e:\n    # Handle externally after graph execution fails\n    result = {\"messages\": [\"Fallback: recursion limit exceeded\"]}\n```\n\nThe key differences between these approaches are:\n\n| Approach                                  | Detection            | Handling                             | Control Flow                       |\n| ----------------------------------------- | -------------------- | ------------------------------------ | ---------------------------------- |\n| Proactive (using `RemainingSteps`)        | Before limit reached | Inside graph via conditional routing | Graph continues to completion node |\n| Reactive (catching `GraphRecursionError`) | After limit exceeded | Outside graph in try/catch           | Graph execution terminated         |\n\n**Proactive advantages:**\n\n* Graceful degradation within the graph\n* Can save intermediate state in checkpoints\n* Better user experience with partial results\n* Graph completes normally (no exception)\n\n**Reactive advantages:**\n\n* Simpler implementation\n* No need to modify graph logic\n* Centralized error handling", "summary": "Compares proactive (internal monitoring with RemainingSteps) and reactive (external try/catch) approaches for handling recursion limits in LangGraph, highlighting their detection, handling, and control flow differences.", "keywords": ["RemainingSteps", "GraphRecursionError", "proactive", "reactive", "recursion limit", "StateGraph", "conditional routing", "graceful degradation", "checkpoints", "try/catch"]}