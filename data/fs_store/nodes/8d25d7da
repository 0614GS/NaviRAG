{"node_id": "8d25d7da", "title": "Interrupts", "path": "interrupts > Interrupts", "content": "Interrupts allow you to pause graph execution at specific points and wait for external input before continuing. This enables human-in-the-loop patterns where you need external input to proceed. When an interrupt is triggered, LangGraph saves the graph state using its [persistence](/oss/python/langgraph/persistence) layer and waits indefinitely until you resume execution.\n\nInterrupts work by calling the `interrupt()` function at any point in your graph nodes. The function accepts any JSON-serializable value which is surfaced to the caller. When you're ready to continue, you resume execution by re-invoking the graph using `Command`, which then becomes the return value of the `interrupt()` call from inside the node.\n\nUnlike static breakpoints (which pause before or after specific nodes), interrupts are **dynamic**â€”they can be placed anywhere in your code and can be conditional based on your application logic.\n\n* **Checkpointing keeps your place:** the checkpointer writes the exact graph state so you can resume later, even when in an error state.\n* **`thread_id` is your pointer:** set `config={\"configurable\": {\"thread_id\": ...}}` to tell the checkpointer which state to load.\n* **Interrupt payloads surface as `__interrupt__`:** the values you pass to `interrupt()` return to the caller in the `__interrupt__` field so you know what the graph is waiting on.\n\nThe `thread_id` you choose is effectively your persistent cursor. Reusing it resumes the same checkpoint; using a new value starts a brand-new thread with an empty state.", "summary": "Interrupts in LangGraph allow dynamic pausing of graph execution for external input, with state persistence and resumption via thread IDs.", "keywords": ["interrupt", "LangGraph", "checkpointer", "thread_id", "StateGraph", "Command", "JSON-serializable", "persistence", "resume", "subgraph"]}