{"node_id": "63b311b8", "title": "Create a sequence of steps", "path": "use-graph-api > Use the graph API > Create a sequence of steps", "content": "<Info>\n  **Prerequisites**\n  This guide assumes familiarity with the above section on [state](#define-and-update-state).\n</Info>\n\nHere we demonstrate how to construct a simple sequence of steps. We will show:\n\n1. How to build a sequential graph\n2. Built-in short-hand for constructing similar graphs.\n\nTo add a sequence of nodes, we use the [`add_node`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_node) and [`add_edge`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_edge) methods of our [graph](/oss/python/langgraph/graph-api#stategraph):\n\n```python  theme={null}\nfrom langgraph.graph import START, StateGraph\n\nbuilder = StateGraph(State)\n\n# Add nodes\nbuilder.add_node(step_1)\nbuilder.add_node(step_2)\nbuilder.add_node(step_3)\n\n# Add edges\nbuilder.add_edge(START, \"step_1\")\nbuilder.add_edge(\"step_1\", \"step_2\")\nbuilder.add_edge(\"step_2\", \"step_3\")\n```\n\nWe can also use the built-in shorthand `.add_sequence`:\n\n```python  theme={null}\nbuilder = StateGraph(State).add_sequence([step_1, step_2, step_3])\nbuilder.add_edge(START, \"step_1\")\n```\n\n<Accordion title=\"Why split application steps into a sequence with LangGraph?\">\n  LangGraph makes it easy to add an underlying persistence layer to your application.\n  This allows state to be checkpointed in between the execution of nodes, so your LangGraph nodes govern:\n\n  * How state updates are [checkpointed](/oss/python/langgraph/persistence)\n  * How interruptions are resumed in [human-in-the-loop](/oss/python/langgraph/interrupts) workflows\n  * How we can \"rewind\" and branch-off executions using LangGraph's [time travel](/oss/python/langgraph/use-time-travel) features\n\n  They also determine how execution steps are [streamed](/oss/python/langgraph/streaming), and how your application is visualized and debugged using [Studio](/langsmith/studio).\n\n  Let's demonstrate an end-to-end example. We will create a sequence of three steps:\n\n  1. Populate a value in a key of the state\n  2. Update the same value\n  3. Populate a different value\n\n  Let's first define our [state](/oss/python/langgraph/graph-api#state). This governs the [schema of the graph](/oss/python/langgraph/graph-api#schema), and can also specify how to apply updates. See [this section](#process-state-updates-with-reducers) for more detail.\n\n  In our case, we will just keep track of two values:\n\n  ```python  theme={null}\n  from typing_extensions import TypedDict\n\n  class State(TypedDict):\n      value_1: str\n      value_2: int\n  ```\n\n  Our [nodes](/oss/python/langgraph/graph-api#nodes) are just Python functions that read our graph's state and make updates to it. The first argument to this function will always be the state:\n\n  ```python  theme={null}\n  def step_1(state: State):\n      return {\"value_1\": \"a\"}\n\n  def step_2(state: State):\n      current_value_1 = state[\"value_1\"]\n      return {\"value_1\": f\"{current_value_1} b\"}\n\n  def step_3(state: State):\n      return {\"value_2\": 10}\n  ```\n\n  <Note>\n    Note that when issuing updates to the state, each node can just specify the value of the key it wishes to update.\n\n    By default, this will **overwrite** the value of the corresponding key. You can also use [reducers](/oss/python/langgraph/graph-api#reducers) to control how updates are processedâ€” for example, you can append successive updates to a key instead. See [this section](#process-state-updates-with-reducers) for more detail.\n  </Note>\n\n  Finally, we define the graph. We use [StateGraph](/oss/python/langgraph/graph-api#stategraph) to define a graph that operates on this state.\n\n  We will then use [`add_node`](/oss/python/langgraph/graph-api#messagesstate) and [`add_edge`](/oss/python/langgraph/graph-api#edges) to populate our graph and define its control flow.\n\n  ```python  theme={null}\n  from langgraph.graph import START, StateGraph\n\n  builder = StateGraph(State)\n\n  # Add nodes\n  builder.add_node(step_1)\n  builder.add_node(step_2)\n  builder.add_node(step_3)\n\n  # Add edges\n  builder.add_edge(START, \"step_1\")\n  builder.add_edge(\"step_1\", \"step_2\")\n  builder.add_edge(\"step_2\", \"step_3\")\n  ```\n\n  <Tip>\n    **Specifying custom names**\n    You can specify custom names for nodes using [`add_node`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_node):\n\n    ```python  theme={null}\n    builder.add_node(\"my_node\", step_1)\n    ```\n  </Tip>\n\n  Note that:\n\n  * [`add_edge`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_edge) takes the names of nodes, which for functions defaults to `node.__name__`.\n  * We must specify the entry point of the graph. For this we add an edge with the [START node](/oss/python/langgraph/graph-api#start-node).\n  * The graph halts when there are no more nodes to execute.\n\n  We next [compile](/oss/python/langgraph/graph-api#compiling-your-graph) our graph. This provides a few basic checks on the structure of the graph (e.g., identifying orphaned nodes). If we were adding persistence to our application via a [checkpointer](/oss/python/langgraph/persistence), it would also be passed in here.\n\n  ```python  theme={null}\n  graph = builder.compile()\n  ```\n\n  LangGraph provides built-in utilities for visualizing your graph. Let's inspect our sequence. See [this guide](#visualize-your-graph) for detail on visualization.\n\n  ```python  theme={null}\n  from IPython.display import Image, display\n\n  display(Image(graph.get_graph().draw_mermaid_png()))\n  ```\n\n    <img src=\"https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=fa0376786cc89d704a5435abba178804\" alt=\"Sequence of steps graph\" data-og-width=\"107\" width=\"107\" data-og-height=\"333\" height=\"333\" data-path=\"oss/images/graph_api_image_2.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=280&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=e2d4ec28fa1b03fab44cbcfccd19aa16 280w, https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=560&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=5ab128ae8f12f766384f48e03fa2c35c 560w, https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=840&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=db4260bece32ab8f5045ea7b9b151c45 840w, https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=1100&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=8a93a6970742a83f06fb1a5288668eef 1100w, https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=1650&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=269956fccda17f64def8a69db847d4aa 1650w, https://mintcdn.com/langchain-5e9cc07a/-_xGPoyjhyiDWTPJ/oss/images/graph_api_image_2.png?w=2500&fit=max&auto=format&n=-_xGPoyjhyiDWTPJ&q=85&s=40f495cb5fbca4aa2c960083a50af52e 2500w\" />\n\n  Let's proceed with a simple invocation:\n\n  ```python  theme={null}\n  graph.invoke({\"value_1\": \"c\"})\n  ```\n\n  ```\n  {'value_1': 'a b', 'value_2': 10}\n  ```\n\n  Note that:\n\n  * We kicked off invocation by providing a value for a single state key. We must always provide a value for at least one key.\n  * The value we passed in was overwritten by the first node.\n  * The second node updated the value.\n  * The third node populated a different value.\n\n  <Tip>\n    **Built-in shorthand**\n    `langgraph>=0.2.46` includes a built-in short-hand `add_sequence` for adding node sequences. You can compile the same graph as follows:\n\n    ```python  theme={null}\n    builder = StateGraph(State).add_sequence([step_1, step_2, step_3])  # [!code highlight]\n    builder.add_edge(START, \"step_1\")\n\n    graph = builder.compile()\n\n    graph.invoke({\"value_1\": \"c\"})\n    ```\n  </Tip>\n</Accordion>", "summary": "Demonstrates how to create a sequential graph in LangGraph using add_node and add_edge methods, and introduces the add_sequence shorthand for building similar graphs.", "keywords": ["StateGraph", "add_node", "add_edge", "add_sequence", "START", "node", "edge", "sequence", "LangGraph", "graph API"]}