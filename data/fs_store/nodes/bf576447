{"node_id": "bf576447", "title": "Impose a recursion limit", "path": "use-graph-api > Use the graph API > Create and control loops > Impose a recursion limit", "content": "In some applications, we may not have a guarantee that we will reach a given termination condition. In these cases, we can set the graph's [recursion limit](/oss/python/langgraph/graph-api#recursion-limit). This will raise a `GraphRecursionError` after a given number of [supersteps](/oss/python/langgraph/graph-api#graphs). We can then catch and handle this exception:\n\n```python  theme={null}\nfrom langgraph.errors import GraphRecursionError\n\ntry:\n    graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\nexcept GraphRecursionError:\n    print(\"Recursion Error\")\n```\n\n```\nNode A sees []\nNode B sees ['A']\nNode C sees ['A', 'B']\nNode D sees ['A', 'B']\nNode A sees ['A', 'B', 'C', 'D']\nRecursion Error\n```\n\n<Accordion title=\"Extended example: return state on hitting recursion limit\">\n  Instead of raising `GraphRecursionError`, we can introduce a new key to the state that keeps track of the number of steps remaining until reaching the recursion limit. We can then use this key to determine if we should end the run.\n\n  LangGraph implements a special `RemainingSteps` annotation. Under the hood, it creates a `ManagedValue` channel -- a state channel that will exist for the duration of our graph run and no longer.\n\n  ```python  theme={null}\n  import operator\n  from typing import Annotated, Literal\n  from typing_extensions import TypedDict\n  from langgraph.graph import StateGraph, START, END\n  from langgraph.managed.is_last_step import RemainingSteps\n\n  class State(TypedDict):\n      aggregate: Annotated[list, operator.add]\n      remaining_steps: RemainingSteps\n\n  def a(state: State):\n      print(f'Node A sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"A\"]}\n\n  def b(state: State):\n      print(f'Node B sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"B\"]}\n\n  # Define nodes\n  builder = StateGraph(State)\n  builder.add_node(a)\n  builder.add_node(b)\n\n  # Define edges\n  def route(state: State) -> Literal[\"b\", END]:\n      if state[\"remaining_steps\"] <= 2:\n          return END\n      else:\n          return \"b\"\n\n  builder.add_edge(START, \"a\")\n  builder.add_conditional_edges(\"a\", route)\n  builder.add_edge(\"b\", \"a\")\n  graph = builder.compile()\n\n  # Test it out\n  result = graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\n  print(result)\n  ```\n\n  ```\n  Node A sees []\n  Node B sees ['A']\n  Node A sees ['A', 'B']\n  {'aggregate': ['A', 'B', 'A']}\n  ```\n</Accordion>\n\n<Accordion title=\"Extended example: loops with branches\">\n  To better understand how the recursion limit works, let's consider a more complex example. Below we implement a loop, but one step fans out into two nodes:\n\n  ```python  theme={null}\n  import operator\n  from typing import Annotated, Literal\n  from typing_extensions import TypedDict\n  from langgraph.graph import StateGraph, START, END\n\n  class State(TypedDict):\n      aggregate: Annotated[list, operator.add]\n\n  def a(state: State):\n      print(f'Node A sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"A\"]}\n\n  def b(state: State):\n      print(f'Node B sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"B\"]}\n\n  def c(state: State):\n      print(f'Node C sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"C\"]}\n\n  def d(state: State):\n      print(f'Node D sees {state[\"aggregate\"]}')\n      return {\"aggregate\": [\"D\"]}\n\n  # Define nodes\n  builder = StateGraph(State)\n  builder.add_node(a)\n  builder.add_node(b)\n  builder.add_node(c)\n  builder.add_node(d)\n\n  # Define edges\n  def route(state: State) -> Literal[\"b\", END]:\n      if len(state[\"aggregate\"]) < 7:\n          return \"b\"\n      else:\n          return END\n\n  builder.add_edge(START, \"a\")\n  builder.add_conditional_edges(\"a\", route)\n  builder.add_edge(\"b\", \"c\")\n  builder.add_edge(\"b\", \"d\")\n  builder.add_edge([\"c\", \"d\"], \"a\")\n  graph = builder.compile()\n  ```\n\n  ```python  theme={null}\n  from IPython.display import Image, display\n\n  display(Image(graph.get_graph().draw_mermaid_png()))\n  ```\n\n    <img src=\"https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=20e2a9e8c15760eb9ecb07fc411aa70e\" alt=\"Complex loop graph with branches\" data-og-width=\"297\" width=\"297\" data-og-height=\"348\" height=\"348\" data-path=\"oss/images/graph_api_image_8.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=280&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=65ee62a3adb7bedaf7571d9ecdacb908 280w, https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=560&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=e7c4c3341baeed9c747082f69d2b3ded 560w, https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=840&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=b64849cfc877d1b32422f6666d5f93a0 840w, https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=1100&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=3d384eba95e1082504c7ef1d5309dfae 1100w, https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=1650&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=2fef71e345a90e5c2321c0dfda15d91b 1650w, https://mintcdn.com/langchain-5e9cc07a/dL5Sn6Cmy9pwtY0V/oss/images/graph_api_image_8.png?w=2500&fit=max&auto=format&n=dL5Sn6Cmy9pwtY0V&q=85&s=09cf8e8ac3215e359e6e4304c09b3a9f 2500w\" />\n\n  This graph looks complex, but can be conceptualized as loop of [supersteps](/oss/python/langgraph/graph-api#graphs):\n\n  1. Node A\n  2. Node B\n  3. Nodes C and D\n  4. Node A\n  5. ...\n\n  We have a loop of four supersteps, where nodes C and D are executed concurrently.\n\n  Invoking the graph as before, we see that we complete two full \"laps\" before hitting the termination condition:\n\n  ```python  theme={null}\n  result = graph.invoke({\"aggregate\": []})\n  ```\n\n  ```\n  Node A sees []\n  Node B sees ['A']\n  Node D sees ['A', 'B']\n  Node C sees ['A', 'B']\n  Node A sees ['A', 'B', 'C', 'D']\n  Node B sees ['A', 'B', 'C', 'D', 'A']\n  Node D sees ['A', 'B', 'C', 'D', 'A', 'B']\n  Node C sees ['A', 'B', 'C', 'D', 'A', 'B']\n  Node A sees ['A', 'B', 'C', 'D', 'A', 'B', 'C', 'D']\n  ```\n\n  However, if we set the recursion limit to four, we only complete one lap because each lap is four supersteps:\n\n  ```python  theme={null}\n  from langgraph.errors import GraphRecursionError\n\n  try:\n      result = graph.invoke({\"aggregate\": []}, {\"recursion_limit\": 4})\n  except GraphRecursionError:\n      print(\"Recursion Error\")\n  ```\n\n  ```\n  Node A sees []\n  Node B sees ['A']\n  Node C sees ['A', 'B']\n  Node D sees ['A', 'B']\n  Node A sees ['A', 'B', 'C', 'D']\n  Recursion Error\n  ```\n</Accordion>", "summary": "Explains how to set a recursion limit in LangGraph to prevent infinite loops, including handling GraphRecursionError and using RemainingSteps for controlled termination.", "keywords": ["recursion_limit", "GraphRecursionError", "RemainingSteps", "supersteps", "StateGraph", "ManagedValue", "conditional_edges", "invoke", "graph", "loop"]}