{"node_id": "62843401", "title": "Try out your agent", "path": "thinking-in-langgraph > Thinking in LangGraph > Step 5: Wire it together > Try out your agent", "content": "Let's run our agent with an urgent billing issue that needs human review:\n\n<Accordion title=\"Testing the agent\" icon=\"flask\">\n  ```python  theme={null}\n  # Test with an urgent billing issue\n  initial_state = {\n      \"email_content\": \"I was charged twice for my subscription! This is urgent!\",\n      \"sender_email\": \"customer@example.com\",\n      \"email_id\": \"email_123\",\n      \"messages\": []\n  }\n\n  # Run with a thread_id for persistence\n  config = {\"configurable\": {\"thread_id\": \"customer_123\"}}\n  result = app.invoke(initial_state, config)\n  # The graph will pause at human_review\n  print(f\"human review interrupt:{result['__interrupt__']}\")\n\n  # When ready, provide human input to resume\n  from langgraph.types import Command\n\n  human_response = Command(\n      resume={\n          \"approved\": True,\n          \"edited_response\": \"We sincerely apologize for the double charge. I've initiated an immediate refund...\"\n      }\n  )\n\n  # Resume execution\n  final_result = app.invoke(human_response, config)\n  print(f\"Email sent successfully!\")\n  ```\n</Accordion>\n\nThe graph pauses when it hits `interrupt()`, saves everything to the checkpointer, and waits. It can resume days later, picking up exactly where it left off. The `thread_id` ensures all state for this conversation is preserved together.", "summary": "Demonstrates testing an agent with an urgent billing issue, showing how the graph pauses for human review and resumes with input.", "keywords": ["agent", "human_review", "interrupt", "thread_id", "checkpointer", "resume", "Command", "initial_state", "invoke", "LangGraph"]}