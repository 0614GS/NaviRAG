{"node_id": "c105cccf", "title": "Node Caching", "path": "graph-api > Graph API overview > Nodes > Node Caching", "content": "LangGraph supports caching of tasks/nodes based on the input to the node. To use caching:\n\n* Specify a cache when compiling a graph (or specifying an entrypoint)\n* Specify a cache policy for nodes. Each cache policy supports:\n  * `key_func` used to generate a cache key based on the input to a node, which defaults to a `hash` of the input with pickle.\n  * `ttl`, the time to live for the cache in seconds. If not specified, the cache will never expire.\n\nFor example:\n\n```python  theme={null}\nimport time\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph\nfrom langgraph.cache.memory import InMemoryCache\nfrom langgraph.types import CachePolicy\n\n\nclass State(TypedDict):\n    x: int\n    result: int\n\n\nbuilder = StateGraph(State)\n\n\ndef expensive_node(state: State) -> dict[str, int]:\n    # expensive computation\n    time.sleep(2)\n    return {\"result\": state[\"x\"] * 2}\n\n\nbuilder.add_node(\"expensive_node\", expensive_node, cache_policy=CachePolicy(ttl=3))\nbuilder.set_entry_point(\"expensive_node\")\nbuilder.set_finish_point(\"expensive_node\")\n\ngraph = builder.compile(cache=InMemoryCache())\n\nprint(graph.invoke({\"x\": 5}, stream_mode='updates'))    # [!code highlight]\n# [{'expensive_node': {'result': 10}}]\nprint(graph.invoke({\"x\": 5}, stream_mode='updates'))    # [!code highlight]\n# [{'expensive_node': {'result': 10}, '__metadata__': {'cached': True}}]\n```\n\n1. First run takes two seconds to run (due to mocked expensive computation).\n2. Second run utilizes cache and returns quickly.", "summary": "Explains how to enable and configure node caching in LangGraph, including cache policies, key functions, and TTL settings.", "keywords": ["LangGraph", "Node Caching", "CachePolicy", "key_func", "ttl", "InMemoryCache", "StateGraph", "cache key", "hash", "pickle"]}