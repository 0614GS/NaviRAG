{"node_id": "cafeff51", "title": "Decouple return value from saved value", "path": "use-functional-api > Use the functional API > Short-term memory > Decouple return value from saved value", "content": "Use `entrypoint.final` to decouple what is returned to the caller from what is persisted in the checkpoint. This is useful when:\n\n* You want to return a computed result (e.g., a summary or status), but save a different internal value for use on the next invocation.\n* You need to control what gets passed to the previous parameter on the next run.\n\n```python  theme={null}\nfrom langgraph.func import entrypoint\nfrom langgraph.checkpoint.memory import InMemorySaver\n\ncheckpointer = InMemorySaver()\n\n@entrypoint(checkpointer=checkpointer)\ndef accumulate(n: int, *, previous: int | None) -> entrypoint.final[int, int]:\n    previous = previous or 0\n    total = previous + n\n    # Return the *previous* value to the caller but save the *new* total to the checkpoint.\n    return entrypoint.final(value=previous, save=total)\n\nconfig = {\"configurable\": {\"thread_id\": \"my-thread\"}}\n\nprint(accumulate.invoke(1, config=config))  # 0\nprint(accumulate.invoke(2, config=config))  # 1\nprint(accumulate.invoke(3, config=config))  # 3\n```", "summary": "Explains how to use `entrypoint.final` to separate the value returned to the caller from the value saved in the checkpoint for state persistence across invocations.", "keywords": ["entrypoint.final", "checkpoint", "InMemorySaver", "previous parameter", "state persistence", "return value", "saved value", "accumulate", "invoke", "configurable"]}