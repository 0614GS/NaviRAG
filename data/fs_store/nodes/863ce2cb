{"node_id": "863ce2cb", "title": "When to use a task", "path": "functional-api > Functional API overview > When to use a task", "content": "**Tasks** are useful in the following scenarios:\n\n* **Checkpointing**: When you need to save the result of a long-running operation to a checkpoint, so you don't need to recompute it when resuming the workflow.\n* **Human-in-the-loop**: If you're building a workflow that requires human intervention, you MUST use **tasks** to encapsulate any randomness (e.g., API calls) to ensure that the workflow can be resumed correctly. See the [determinism](#determinism) section for more details.\n* **Parallel Execution**: For I/O-bound tasks, **tasks** enable parallel execution, allowing multiple operations to run concurrently without blocking (e.g., calling multiple APIs).\n* **Observability**: Wrapping operations in **tasks** provides a way to track the progress of the workflow and monitor the execution of individual operations using [LangSmith](https://docs.langchain.com/langsmith/home).\n* **Retryable Work**: When work needs to be retried to handle failures or inconsistencies, **tasks** provide a way to encapsulate and manage the retry logic.", "summary": "Tasks are used for checkpointing, human-in-the-loop workflows, parallel execution, observability, and retryable work in functional APIs.", "keywords": ["tasks", "checkpointing", "human-in-the-loop", "parallel execution", "observability", "retryable work", "determinism", "LangSmith", "I/O-bound tasks", "workflow"]}