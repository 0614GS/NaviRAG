{"node_id": "6ad17f47", "title": "Approve or reject", "path": "interrupts > Interrupts > Common patterns > Approve or reject", "content": "One of the most common uses of interrupts is to pause before a critical action and ask for approval. For example, you might want to ask a human to approve an API call, a database change, or any other important decision.\n\n```python  theme={null}\nfrom typing import Literal\nfrom langgraph.types import interrupt, Command\n\ndef approval_node(state: State) -> Command[Literal[\"proceed\", \"cancel\"]]:\n    # Pause execution; payload shows up under result[\"__interrupt__\"]\n    is_approved = interrupt({\n        \"question\": \"Do you want to proceed with this action?\",\n        \"details\": state[\"action_details\"]\n    })\n\n    # Route based on the response\n    if is_approved:\n        return Command(goto=\"proceed\")  # Runs after the resume payload is provided\n    else:\n        return Command(goto=\"cancel\")\n```\n\nWhen you resume the graph, pass `true` to approve or `false` to reject:\n\n```python  theme={null}\n# To approve\ngraph.invoke(Command(resume=True), config=config)\n\n# To reject\ngraph.invoke(Command(resume=False), config=config)\n```\n\n<Accordion title=\"Full example\">\n  ```python  theme={null}\n  from typing import Literal, Optional, TypedDict\n\n  from langgraph.checkpoint.memory import MemorySaver\n  from langgraph.graph import StateGraph, START, END\n  from langgraph.types import Command, interrupt\n\n\n  class ApprovalState(TypedDict):\n      action_details: str\n      status: Optional[Literal[\"pending\", \"approved\", \"rejected\"]]\n\n\n  def approval_node(state: ApprovalState) -> Command[Literal[\"proceed\", \"cancel\"]]:\n      # Expose details so the caller can render them in a UI\n      decision = interrupt({\n          \"question\": \"Approve this action?\",\n          \"details\": state[\"action_details\"],\n      })\n\n      # Route to the appropriate node after resume\n      return Command(goto=\"proceed\" if decision else \"cancel\")\n\n\n  def proceed_node(state: ApprovalState):\n      return {\"status\": \"approved\"}\n\n\n  def cancel_node(state: ApprovalState):\n      return {\"status\": \"rejected\"}\n\n\n  builder = StateGraph(ApprovalState)\n  builder.add_node(\"approval\", approval_node)\n  builder.add_node(\"proceed\", proceed_node)\n  builder.add_node(\"cancel\", cancel_node)\n  builder.add_edge(START, \"approval\")\n  builder.add_edge(\"proceed\", END)\n  builder.add_edge(\"cancel\", END)\n\n  # Use a more durable checkpointer in production\n  checkpointer = MemorySaver()\n  graph = builder.compile(checkpointer=checkpointer)\n\n  config = {\"configurable\": {\"thread_id\": \"approval-123\"}}\n  initial = graph.invoke(\n      {\"action_details\": \"Transfer $500\", \"status\": \"pending\"},\n      config=config,\n  )\n  print(initial[\"__interrupt__\"])  # -> [Interrupt(value={'question': ..., 'details': ...})]\n\n  # Resume with the decision; True routes to proceed, False to cancel\n  resumed = graph.invoke(Command(resume=True), config=config)\n  print(resumed[\"status\"])  # -> \"approved\"\n  ```\n</Accordion>", "summary": "Demonstrates using interrupts to pause execution for human approval before critical actions, with code examples for approval/rejection logic and graph resumption.", "keywords": ["interrupt", "approval_node", "Command", "resume", "StateGraph", "checkpointer", "MemorySaver", "TypedDict", "goto", "langgraph"]}