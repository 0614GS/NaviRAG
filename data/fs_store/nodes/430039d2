{"node_id": "430039d2", "title": "Add retry policies", "path": "use-graph-api > Use the graph API > Add retry policies", "content": "There are many use cases where you may wish for your node to have a custom retry policy, for example if you are calling an API, querying a database, or calling an LLM, etc. LangGraph lets you add retry policies to nodes.\n\nTo configure a retry policy, pass the `retry_policy` parameter to the [`add_node`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_node). The `retry_policy` parameter takes in a `RetryPolicy` named tuple object. Below we instantiate a `RetryPolicy` object with the default parameters and associate it with a node:\n\n```python  theme={null}\nfrom langgraph.types import RetryPolicy\n\nbuilder.add_node(\n    \"node_name\",\n    node_function,\n    retry_policy=RetryPolicy(),\n)\n```\n\nBy default, the `retry_on` parameter uses the `default_retry_on` function, which retries on any exception except for the following:\n\n* `ValueError`\n* `TypeError`\n* `ArithmeticError`\n* `ImportError`\n* `LookupError`\n* `NameError`\n* `SyntaxError`\n* `RuntimeError`\n* `ReferenceError`\n* `StopIteration`\n* `StopAsyncIteration`\n* `OSError`\n\nIn addition, for exceptions from popular http request libraries such as `requests` and `httpx` it only retries on 5xx status codes.\n\n<Accordion title=\"Extended example: customizing retry policies\">\n  Consider an example in which we are reading from a SQL database. Below we pass two different retry policies to nodes:\n\n  ```python  theme={null}\n  import sqlite3\n  from typing_extensions import TypedDict\n  from langchain.chat_models import init_chat_model\n  from langgraph.graph import END, MessagesState, StateGraph, START\n  from langgraph.types import RetryPolicy\n  from langchain_community.utilities import SQLDatabase\n  from langchain.messages import AIMessage\n\n  db = SQLDatabase.from_uri(\"sqlite:///:memory:\")\n  model = init_chat_model(\"claude-haiku-4-5-20251001\")\n\n  def query_database(state: MessagesState):\n      query_result = db.run(\"SELECT * FROM Artist LIMIT 10;\")\n      return {\"messages\": [AIMessage(content=query_result)]}\n\n  def call_model(state: MessagesState):\n      response = model.invoke(state[\"messages\"])\n      return {\"messages\": [response]}\n\n  # Define a new graph\n  builder = StateGraph(MessagesState)\n  builder.add_node(\n      \"query_database\",\n      query_database,\n      retry_policy=RetryPolicy(retry_on=sqlite3.OperationalError),\n  )\n  builder.add_node(\"model\", call_model, retry_policy=RetryPolicy(max_attempts=5))\n  builder.add_edge(START, \"model\")\n  builder.add_edge(\"model\", \"query_database\")\n  builder.add_edge(\"query_database\", END)\n  graph = builder.compile()\n  ```\n</Accordion>", "summary": "Explains how to add custom retry policies to nodes in LangGraph for API calls, database queries, and LLM interactions, including default exception handling and customization examples.", "keywords": ["RetryPolicy", "add_node", "retry_on", "default_retry_on", "max_attempts", "sqlite3.OperationalError", "StateGraph", "langgraph.types", "5xx status codes", "retry_policy parameter"]}