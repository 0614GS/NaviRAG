{"node_id": "acc768e6", "title": "Partial execution", "path": "test > Test > Partial execution", "content": "For agents made up of larger graphs, you may wish to test partial execution paths within your agent rather than the entire flow end-to-end. In some cases, it may make semantic sense to [restructure these sections as subgraphs](/oss/python/langgraph/use-subgraphs), which you can invoke in isolation as normal.\n\nHowever, if you do not wish to make changes to your agent graph's overall structure, you can use LangGraph's persistence mechanisms to simulate a state where your agent is paused right before the beginning of the desired section, and will pause again at the end of the desired section. The steps are as follows:\n\n1. Compile your agent with a checkpointer (the in-memory checkpointer [`InMemorySaver`](https://reference.langchain.com/python/langgraph/checkpoints/#langgraph.checkpoint.memory.InMemorySaver) will suffice for testing).\n2. Call your agent's [`update_state`](/oss/python/langgraph/use-time-travel) method with an [`as_node`](/oss/python/langgraph/persistence#as-node) parameter set to the name of the node *before* the one you want to start your test.\n3. Invoke your agent with the same `thread_id` you used to update the state and an `interrupt_after` parameter set to the name of the node you want to stop at.\n\nHere's an example that executes only the second and third nodes in a linear graph:\n\n```python  theme={null}\nimport pytest\n\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef create_graph() -> StateGraph:\n    class MyState(TypedDict):\n        my_key: str\n\n    graph = StateGraph(MyState)\n    graph.add_node(\"node1\", lambda state: {\"my_key\": \"hello from node1\"})\n    graph.add_node(\"node2\", lambda state: {\"my_key\": \"hello from node2\"})\n    graph.add_node(\"node3\", lambda state: {\"my_key\": \"hello from node3\"})\n    graph.add_node(\"node4\", lambda state: {\"my_key\": \"hello from node4\"})\n    graph.add_edge(START, \"node1\")\n    graph.add_edge(\"node1\", \"node2\")\n    graph.add_edge(\"node2\", \"node3\")\n    graph.add_edge(\"node3\", \"node4\")\n    graph.add_edge(\"node4\", END)\n    return graph\n\ndef test_partial_execution_from_node2_to_node3() -> None:\n    checkpointer = MemorySaver()\n    graph = create_graph()\n    compiled_graph = graph.compile(checkpointer=checkpointer)\n    compiled_graph.update_state(\n        config={\n          \"configurable\": {\n            \"thread_id\": \"1\"\n          }\n        },\n        # The state passed into node 2 - simulating the state at\n        # the end of node 1\n        values={\"my_key\": \"initial_value\"},\n        # Update saved state as if it came from node 1\n        # Execution will resume at node 2\n        as_node=\"node1\",\n    )\n    result = compiled_graph.invoke(\n        # Resume execution by passing None\n        None,\n        config={\"configurable\": {\"thread_id\": \"1\"}},\n        # Stop after node 3 so that node 4 doesn't run\n        interrupt_after=\"node3\",\n    )\n    assert result[\"my_key\"] == \"hello from node3\"\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/test.mdx) or [file an issue](https://github.com/langchain-ai/docs/issues/new/choose).\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>\n\n\n---\n\n> To find navigation and other pages in this documentation, fetch the llms.txt file at: https://docs.langchain.com/llms.txt", "summary": "Describes how to test partial execution paths in LangGraph agents using persistence mechanisms, including steps and a code example.", "keywords": ["LangGraph", "partial execution", "persistence", "checkpointer", "InMemorySaver", "update_state", "as_node", "interrupt_after", "StateGraph", "thread_id"]}