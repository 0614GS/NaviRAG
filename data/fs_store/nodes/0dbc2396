{"node_id": "0dbc2396", "title": "Invoke a graph from a node", "path": "use-subgraphs > Subgraphs > Invoke a graph from a node", "content": "A simple way to implement a subgraph is to invoke a graph from inside the node of another graph. In this case subgraphs can have **completely different schemas** from the parent graph (no shared keys). For example, you might want to keep a private message history for each of the agents in a [multi-agent](/oss/python/langchain/multi-agent) system.\n\nIf that's the case for your application, you need to define a node **function that invokes the subgraph**. This function needs to transform the input (parent) state to the subgraph state before invoking the subgraph, and transform the results back to the parent state before returning the state update from the node.\n\n```python  theme={null}\nfrom typing_extensions import TypedDict\nfrom langgraph.graph.state import StateGraph, START\n\nclass SubgraphState(TypedDict):\n    bar: str\n\n# Subgraph\n\ndef subgraph_node_1(state: SubgraphState):\n    return {\"bar\": \"hi! \" + state[\"bar\"]}\n\nsubgraph_builder = StateGraph(SubgraphState)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nclass State(TypedDict):\n    foo: str\n\ndef call_subgraph(state: State):\n    # Transform the state to the subgraph state\n    subgraph_output = subgraph.invoke({\"bar\": state[\"foo\"]})  # [!code highlight]\n    # Transform response back to the parent state\n    return {\"foo\": subgraph_output[\"bar\"]}\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", call_subgraph)\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n```\n\n<Accordion title=\"Full example: different state schemas\">\n  ```python  theme={null}\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START\n\n  # Define subgraph\n  class SubgraphState(TypedDict):\n      # note that none of these keys are shared with the parent graph state\n      bar: str\n      baz: str\n\n  def subgraph_node_1(state: SubgraphState):\n      return {\"baz\": \"baz\"}\n\n  def subgraph_node_2(state: SubgraphState):\n      return {\"bar\": state[\"bar\"] + state[\"baz\"]}\n\n  subgraph_builder = StateGraph(SubgraphState)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_node(subgraph_node_2)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n  subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n  subgraph = subgraph_builder.compile()\n\n  # Define parent graph\n  class ParentState(TypedDict):\n      foo: str\n\n  def node_1(state: ParentState):\n      return {\"foo\": \"hi! \" + state[\"foo\"]}\n\n  def node_2(state: ParentState):\n      # Transform the state to the subgraph state\n      response = subgraph.invoke({\"bar\": state[\"foo\"]})\n      # Transform response back to the parent state\n      return {\"foo\": response[\"bar\"]}\n\n\n  builder = StateGraph(ParentState)\n  builder.add_node(\"node_1\", node_1)\n  builder.add_node(\"node_2\", node_2)\n  builder.add_edge(START, \"node_1\")\n  builder.add_edge(\"node_1\", \"node_2\")\n  graph = builder.compile()\n\n  for chunk in graph.stream({\"foo\": \"foo\"}, subgraphs=True):\n      print(chunk)\n  ```\n\n  ```\n  ((), {'node_1': {'foo': 'hi! foo'}})\n  (('node_2:577b710b-64ae-31fb-9455-6a4d4cc2b0b9',), {'subgraph_node_1': {'baz': 'baz'}})\n  (('node_2:577b710b-64ae-31fb-9455-6a4d4cc2b0b9',), {'subgraph_node_2': {'bar': 'hi! foobaz'}})\n  ((), {'node_2': {'foo': 'hi! foobaz'}})\n  ```\n</Accordion>\n\n<Accordion title=\"Full example: different state schemas (two levels of subgraphs)\">\n  This is an example with two levels of subgraphs: parent -> child -> grandchild.\n\n  ```python  theme={null}\n  # Grandchild graph\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START, END\n\n  class GrandChildState(TypedDict):\n      my_grandchild_key: str\n\n  def grandchild_1(state: GrandChildState) -> GrandChildState:\n      # NOTE: child or parent keys will not be accessible here\n      return {\"my_grandchild_key\": state[\"my_grandchild_key\"] + \", how are you\"}\n\n\n  grandchild = StateGraph(GrandChildState)\n  grandchild.add_node(\"grandchild_1\", grandchild_1)\n\n  grandchild.add_edge(START, \"grandchild_1\")\n  grandchild.add_edge(\"grandchild_1\", END)\n\n  grandchild_graph = grandchild.compile()\n\n  # Child graph\n  class ChildState(TypedDict):\n      my_child_key: str\n\n  def call_grandchild_graph(state: ChildState) -> ChildState:\n      # NOTE: parent or grandchild keys won't be accessible here\n      grandchild_graph_input = {\"my_grandchild_key\": state[\"my_child_key\"]}\n      grandchild_graph_output = grandchild_graph.invoke(grandchild_graph_input)\n      return {\"my_child_key\": grandchild_graph_output[\"my_grandchild_key\"] + \" today?\"}\n\n  child = StateGraph(ChildState)\n  # We're passing a function here instead of just compiled graph (`grandchild_graph`)\n  child.add_node(\"child_1\", call_grandchild_graph)\n  child.add_edge(START, \"child_1\")\n  child.add_edge(\"child_1\", END)\n  child_graph = child.compile()\n\n  # Parent graph\n  class ParentState(TypedDict):\n      my_key: str\n\n  def parent_1(state: ParentState) -> ParentState:\n      # NOTE: child or grandchild keys won't be accessible here\n      return {\"my_key\": \"hi \" + state[\"my_key\"]}\n\n  def parent_2(state: ParentState) -> ParentState:\n      return {\"my_key\": state[\"my_key\"] + \" bye!\"}\n\n  def call_child_graph(state: ParentState) -> ParentState:\n      child_graph_input = {\"my_child_key\": state[\"my_key\"]}\n      child_graph_output = child_graph.invoke(child_graph_input)\n      return {\"my_key\": child_graph_output[\"my_child_key\"]}\n\n  parent = StateGraph(ParentState)\n  parent.add_node(\"parent_1\", parent_1)\n  # We're passing a function here instead of just a compiled graph (`child_graph`)\n  parent.add_node(\"child\", call_child_graph)\n  parent.add_node(\"parent_2\", parent_2)\n\n  parent.add_edge(START, \"parent_1\")\n  parent.add_edge(\"parent_1\", \"child\")\n  parent.add_edge(\"child\", \"parent_2\")\n  parent.add_edge(\"parent_2\", END)\n\n  parent_graph = parent.compile()\n\n  for chunk in parent_graph.stream({\"my_key\": \"Bob\"}, subgraphs=True):\n      print(chunk)\n  ```\n\n  ```\n  ((), {'parent_1': {'my_key': 'hi Bob'}})\n  (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b', 'child_1:781bb3b1-3971-84ce-810b-acf819a03f9c'), {'grandchild_1': {'my_grandchild_key': 'hi Bob, how are you'}})\n  (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b',), {'child_1': {'my_child_key': 'hi Bob, how are you today?'}})\n  ((), {'child': {'my_key': 'hi Bob, how are you today?'}})\n  ((), {'parent_2': {'my_key': 'hi Bob, how are you today? bye!'}})\n  ```\n</Accordion>", "summary": "Explains how to invoke a subgraph from a node in a parent graph, including state transformation between different schemas, with Python code examples.", "keywords": ["subgraph", "StateGraph", "invoke", "TypedDict", "state transformation", "node", "parent graph", "multi-agent", "schema", "LangGraph"]}