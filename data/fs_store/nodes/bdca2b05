{"node_id": "bdca2b05", "title": "Use Pydantic models for graph state", "path": "use-graph-api > Use the graph API > Define and update state > Use Pydantic models for graph state", "content": "A [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.StateGraph) accepts a [`state_schema`](https://reference.langchain.com/python/langchain/middleware/#langchain.agents.middleware.AgentMiddleware.state_schema) argument on initialization that specifies the \"shape\" of the state that the nodes in the graph can access and update.\n\nIn our examples, we typically use a python-native `TypedDict` or [`dataclass`](https://docs.python.org/3/library/dataclasses.html) for `state_schema`, but [`state_schema`](https://reference.langchain.com/python/langchain/middleware/#langchain.agents.middleware.AgentMiddleware.state_schema) can be any [type](https://docs.python.org/3/library/stdtypes.html#type-objects).\n\nHere, we'll see how a [Pydantic BaseModel](https://docs.pydantic.dev/latest/api/base_model/) can be used for [`state_schema`](https://reference.langchain.com/python/langchain/middleware/#langchain.agents.middleware.AgentMiddleware.state_schema) to add run-time validation on **inputs**.\n\n<Note>\n  **Known Limitations**\n\n  * Currently, the output of the graph will **NOT** be an instance of a pydantic model.\n  * Run-time validation only occurs on inputs to the first node in the graph, not on subsequent nodes or outputs.\n  * The validation error trace from pydantic does not show which node the error arises in.\n  * Pydantic's recursive validation can be slow. For performance-sensitive applications, you may want to consider using a `dataclass` instead.\n</Note>\n\n```python  theme={null}\nfrom langgraph.graph import StateGraph, START, END\nfrom typing_extensions import TypedDict\nfrom pydantic import BaseModel\n\n# The overall state of the graph (this is the public state shared across nodes)\nclass OverallState(BaseModel):\n    a: str\n\ndef node(state: OverallState):\n    return {\"a\": \"goodbye\"}\n\n# Build the state graph\nbuilder = StateGraph(OverallState)\nbuilder.add_node(node)  # node_1 is the first node\nbuilder.add_edge(START, \"node\")  # Start the graph with node_1\nbuilder.add_edge(\"node\", END)  # End the graph after node_1\ngraph = builder.compile()\n\n# Test the graph with a valid input\ngraph.invoke({\"a\": \"hello\"})\n```\n\nInvoke the graph with an **invalid** input\n\n```python  theme={null}\ntry:\n    graph.invoke({\"a\": 123})  # Should be a string\nexcept Exception as e:\n    print(\"An exception was raised because `a` is an integer rather than a string.\")\n    print(e)\n```\n\n```\nAn exception was raised because `a` is an integer rather than a string.\n1 validation error for OverallState\na\n  Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    For further information visit https://errors.pydantic.dev/2.9/v/string_type\n```\n\nSee below for additional features of Pydantic model state:\n\n<Accordion title=\"Serialization Behavior\">\n  When using Pydantic models as state schemas, it's important to understand how serialization works, especially when:\n\n  * Passing Pydantic objects as inputs\n  * Receiving outputs from the graph\n  * Working with nested Pydantic models\n\n  Let's see these behaviors in action.\n\n  ```python  theme={null}\n  from langgraph.graph import StateGraph, START, END\n  from pydantic import BaseModel\n\n  class NestedModel(BaseModel):\n      value: str\n\n  class ComplexState(BaseModel):\n      text: str\n      count: int\n      nested: NestedModel\n\n  def process_node(state: ComplexState):\n      # Node receives a validated Pydantic object\n      print(f\"Input state type: {type(state)}\")\n      print(f\"Nested type: {type(state.nested)}\")\n      # Return a dictionary update\n      return {\"text\": state.text + \" processed\", \"count\": state.count + 1}\n\n  # Build the graph\n  builder = StateGraph(ComplexState)\n  builder.add_node(\"process\", process_node)\n  builder.add_edge(START, \"process\")\n  builder.add_edge(\"process\", END)\n  graph = builder.compile()\n\n  # Create a Pydantic instance for input\n  input_state = ComplexState(text=\"hello\", count=0, nested=NestedModel(value=\"test\"))\n  print(f\"Input object type: {type(input_state)}\")\n\n  # Invoke graph with a Pydantic instance\n  result = graph.invoke(input_state)\n  print(f\"Output type: {type(result)}\")\n  print(f\"Output content: {result}\")\n\n  # Convert back to Pydantic model if needed\n  output_model = ComplexState(**result)\n  print(f\"Converted back to Pydantic: {type(output_model)}\")\n  ```\n</Accordion>\n\n<Accordion title=\"Runtime Type Coercion\">\n  Pydantic performs runtime type coercion for certain data types. This can be helpful but also lead to unexpected behavior if you're not aware of it.\n\n  ```python  theme={null}\n  from langgraph.graph import StateGraph, START, END\n  from pydantic import BaseModel\n\n  class CoercionExample(BaseModel):\n      # Pydantic will coerce string numbers to integers\n      number: int\n      # Pydantic will parse string booleans to bool\n      flag: bool\n\n  def inspect_node(state: CoercionExample):\n      print(f\"number: {state.number} (type: {type(state.number)})\")\n      print(f\"flag: {state.flag} (type: {type(state.flag)})\")\n      return {}\n\n  builder = StateGraph(CoercionExample)\n  builder.add_node(\"inspect\", inspect_node)\n  builder.add_edge(START, \"inspect\")\n  builder.add_edge(\"inspect\", END)\n  graph = builder.compile()\n\n  # Demonstrate coercion with string inputs that will be converted\n  result = graph.invoke({\"number\": \"42\", \"flag\": \"true\"})\n\n  # This would fail with a validation error\n  try:\n      graph.invoke({\"number\": \"not-a-number\", \"flag\": \"true\"})\n  except Exception as e:\n      print(f\"\\nExpected validation error: {e}\")\n  ```\n</Accordion>\n\n<Accordion title=\"Working with Message Models\">\n  When working with LangChain message types in your state schema, there are important considerations for serialization. You should use `AnyMessage` (rather than `BaseMessage`) for proper serialization/deserialization when using message objects over the wire.\n\n  ```python  theme={null}\n  from langgraph.graph import StateGraph, START, END\n  from pydantic import BaseModel\n  from langchain.messages import HumanMessage, AIMessage, AnyMessage\n  from typing import List\n\n  class ChatState(BaseModel):\n      messages: List[AnyMessage]\n      context: str\n\n  def add_message(state: ChatState):\n      return {\"messages\": state.messages + [AIMessage(content=\"Hello there!\")]}\n\n  builder = StateGraph(ChatState)\n  builder.add_node(\"add_message\", add_message)\n  builder.add_edge(START, \"add_message\")\n  builder.add_edge(\"add_message\", END)\n  graph = builder.compile()\n\n  # Create input with a message\n  initial_state = ChatState(\n      messages=[HumanMessage(content=\"Hi\")], context=\"Customer support chat\"\n  )\n\n  result = graph.invoke(initial_state)\n  print(f\"Output: {result}\")\n\n  # Convert back to Pydantic model to see message types\n  output_model = ChatState(**result)\n  for i, msg in enumerate(output_model.messages):\n      print(f\"Message {i}: {type(msg).__name__} - {msg.content}\")\n  ```\n</Accordion>", "summary": "Explains using Pydantic BaseModel as state_schema in LangGraph's StateGraph for runtime input validation, with notes on limitations and advanced features like serialization, type coercion, and message models.", "keywords": ["StateGraph", "state_schema", "Pydantic BaseModel", "TypedDict", "dataclass", "runtime validation", "serialization", "type coercion", "AnyMessage", "LangGraph"]}